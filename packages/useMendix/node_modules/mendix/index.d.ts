import Big from 'big.js';
import { ImageStyle } from 'react-native';
import { ImageURISource } from 'react-native';
import { ReactNode } from 'react';
import { TextStyle } from 'react-native';
import { ViewStyle } from 'react-native';

/**
 * Prop value representing an action, like {@link https://docs.mendix.com/refguide/action-button#events-on-click | On Click)
 * of an Action Button.
 *
 * @remarks
 * For a "Do nothing" action the component will receive `undefined` value instead.
 */
export declare interface ActionValue {
    /**
     * Whether an action can be executed under current circumstances.
     *
     * @example
     * A “Call a microflow” action triggering a microflow with a parameter cannot be executed until a parameter object
     * is available, e.g. when a parent Data view finished loading.
     *
     * @remark
     * This value does not depend on the current value of {@link isExecuting}, even if the {@link disabledDuringExecution}
     * flag is set to true.
     * @remark
     * An attempt to {@link execute} an action that cannot be executed will cause a DEBUG-level warning message.
     */
    readonly canExecute: boolean;
    /* Excluded from this release type: isAuthorized */
    /**
     * Indicates whether an action is currently running.
     *
     * @example
     * A long-running action like the “Call a microflow” action can take seconds to complete - way longer than
     * an expected UI response time. So your component might use this information to e.g. render an inline loading
     * indicator to match UX expectations.
     *
     * Often it is not desirable to allow user to trigger multiple actions in parallel - hence, a component (maybe based
     * on a configuration) can decide to skip triggering a new action while previous one is still running.
     *
     * @remark
     * It indicates only whether the current action is running. It does not indicate whether a target Nanoflow,
     * Microflow, or object operation like Save is running due to e.g. another action.
     */
    readonly isExecuting: boolean;
    /* Excluded from this release type: disabledDuringExecution */
    /**
     * Triggers the action.
     *
     * @remark
     * It returns nothing and does not guarantee that the action will be started synchronously. But when it actually
     * starts, the widget will receive a new prop with the {@link isExecuting} flag set.
     * @remark
     * An action can only be executed if {@link canExecute} is true. Additionally, if the {@link disabledDuringExecution}
     * flag is set, it can only be executed if it is not already executing. An attempt to execute an action that cannot
     * be executed will cause a DEBUG-level warning message.
     */
    execute: () => void;
}

/** A logical `and` condition which takes two or more {@link FilterCondition} arguments. */
declare type AndCondition = MultiaryFunctionExpression<"and", FilterCondition>;

/**
 * An expression which represents an association.
 */
declare interface AssociationExpression {
    /** Identifies this expression as an association expression. */
    readonly type: "association";
    /** The association id as specified in the {@link ListAssociationValue.id} property. */
    readonly associationId: ListAssociationId;
}

declare type AssociationType = "Reference" | "ReferenceSet";

/**
 * An expression which represents an attribute.
 */
declare interface AttributeExpression {
    /** Identifies this expression as an attribute expression. */
    readonly type: "attribute";
    /** The attribute id as specified in the {@link ListAttributeValue.id} property. */
    readonly attributeId: ListAttributeId;
}

declare type AttributeType_2 = "AutoNumber" | "Binary" | "Boolean" | "DateTime" | "Decimal" | "Enum" | "EnumSet" | "HashString" | "Integer" | "Long" | "ObjectReference" | "ObjectReferenceSet" | "String";

declare type AttributeValue_2 = undefined | string | boolean | Date | BigJS_2 | GUID_2 | GUID_2[];

declare type BigJS_2 = Big;

declare interface BinaryFunctionExpression<TName extends FilterFunction, TArg1 extends FilterExpression, TArg2 = TArg1> extends FunctionExpression<TName> {
    readonly arg1: TArg1;
    readonly arg2: TArg2;
}

declare type BooleanFunction = "and" | "or" | "not";

declare type ComparisonFunction = EqualityFunction | ">" | ">=" | "<" | "<=";

/** An `contains` condition which takes a {@link AttributeExpression} or a {@link AssociationExpression} and a {@link LiteralExpression} as arguments. */
declare type ContainsCondition = BinaryFunctionExpression<"contains", AttributeExpression | AssociationExpression, LiteralExpression>;

declare interface CustomDateTimeFormatterConfig {
    readonly type: "custom";
    readonly pattern: string;
}

declare interface CustomStyle {
    [key: string]: string | number;
}

/**
 * Built-in formatter/parser for editable date/time values (represented by the {@link Date} type). This formatter type
 * supports configuration options for date/time formatting and parsing. It also allows a fallback date to be passed as
 * a second argument to the {@link parse} method.
 */
export declare interface DateTimeFormatter extends TypedFormatter<Date> {
    /**
     * Identifies this formatter as a {@link DateTimeFormatter} within the {@link ValueFormatter} union type.
     */
    readonly type: FormatterType.DateTime;
    /**
     * The configuration of this formatter.
     */
    readonly config: DateTimeFormatterConfig;
    /**
     * Parses the given display value.
     *
     * @param value The value to parse.
     * @param fallbackValue The fallback date to use when parsing, which may be omitted.
     *
     * @return A {@link ParseResult} indicating whether the parser could produce a valid result.
     */
    parse: (value: string, fallbackValue?: Date) => ParseResult<Date>;
    /**
     * Creates a formatter/parser for date and time with the given configuration options.
     *
     * @param config The new configuration options to use.
     *
     * @return A new {@link DateTimeFormatter}.
     *
     * @remark
     * Note that this function does not alter the existing formatter in any way, it only returns a new one with a
     * different configuration.
     */
    withConfig: (config: DateTimeFormatterConfig) => DateTimeFormatter;
    /**
     * @return A placeholder text matching the date/time pattern of this formatter.
     */
    getFormatPlaceholder: () => Option_2<string>;
}

export declare type DateTimeFormatterConfig = DefaultDateTimeFormatterConfig | CustomDateTimeFormatterConfig;

declare type DayComparisonFunction = "day:=" | "day:!=" | "day:>" | "day:>=" | "day:<" | "day:<=";

/** An `dayEquals` (`day:=`) condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type DayEqualsCondition = BinaryFunctionExpression<"day:=", AttributeExpression, LiteralExpression>;

/** A `dayGreaterThan` (`day:>`) condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type DayGreaterThanCondition = BinaryFunctionExpression<"day:>", AttributeExpression, LiteralExpression>;

/** A `dayGreaterThanOrEqual` (`day:>=`) condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type DayGreaterThanOrEqualCondition = BinaryFunctionExpression<"day:>=", AttributeExpression, LiteralExpression>;

/** A `dayLessThan` (`day:<`) condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type DayLessThanCondition = BinaryFunctionExpression<"day:<", AttributeExpression, LiteralExpression>;

/** A `dayLessThanOrEqual` (`day:<=`) condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type DayLessThanOrEqualCondition = BinaryFunctionExpression<"day:<=", AttributeExpression, LiteralExpression>;

/** A `dayNotEqual` (`day:!=`) condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type DayNotEqualCondition = BinaryFunctionExpression<"day:!=", AttributeExpression, LiteralExpression>;

declare interface DefaultDateTimeFormatterConfig {
    readonly type: "date" | "time" | "datetime";
}

/**
 * Prop value representing a dynamically loaded value which may not always be available, as expressed by its {@link ValueStatus}.
 *
 * @property status The current status of the value.
 * @property value The value, if available, or the previous value when currently loading.
 *
 * @typeParam T The type of the contained value.
 */
export declare type DynamicValue<T> = {
    readonly status: ValueStatus.Available;
    readonly value: T;
} | {
    readonly status: ValueStatus.Unavailable;
    readonly value: undefined;
} | {
    readonly status: ValueStatus.Loading;
    readonly value: Option_2<T>;
};

/**
 * Prop value representing an editable value with formatting, parsing and validation. Like {@link DynamicValue}, this
 * value has a {@link ValueStatus}. Additionally, the value may be in a {@link readOnly} state which prevents editing.
 *
 * @typeParam T The type of the contained value, which must be a subtype of {@link AttributeValue}.
 */
export declare interface EditableValue<T extends AttributeValue_2 = AttributeValue_2> {
    /**
     * The current status of the value.
     */
    readonly status: ValueStatus;
    /**
     * Whether the value is read-only.
     *
     * @example
     * A read-only value can be the result of access restrictions or the current {@link status}.
     *
     * @remark
     * An attempt to call {@link setTextValue} or {@link setValue} while the value is read-only will cause a DEBUG-level
     * warning message.
     */
    readonly readOnly: boolean;
    /**
     * The value, if available, or the previous value when currently loading.
     */
    readonly value: Option_2<T>;
    /**
     * The formatted text value for the current value, as produced by {@link formatter}.
     *
     * @remark
     * To change the format, use {@link setFormatter}.
     */
    readonly displayValue: string;
    /**
     * Sets the value directly without parsing.
     *
     * @param value The new value.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     * @remark
     * An attempt to call this function while the value is read-only will cause a DEBUG-level warning message.
     */
    readonly setValue: (value: Option_2<T>) => void;
    /**
     * Sets the text value, which will be parsed using the current {@link formatter} to produce the new internal value.
     *
     * If the text value is invalid, this will result in a {@link validation} message.
     *
     * @param value The new text value.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     * @remark
     * An attempt to call this function while the value is read-only will cause a DEBUG-level warning message.
     */
    readonly setTextValue: (value: string) => void;
    /**
     * The validation message, if the value is currently invalid.
     *
     * @example
     * A validation message will be set if a text value cannot be parsed by the current {@link formatter} or if the
     * parsed value is invalid for its attribute or rejected by a validation expression.
     *
     * @remark
     * To set a custom validator, use {@link setValidator}.
     */
    readonly validation: Option_2<string>;
    /**
     * Sets a custom validator function.
     *
     * @param validator The new custom validator, or `undefined` to clear it.
     *
     * @remark
     * The custom validator does not replace the other types of validations which occur when the value is changed.
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    readonly setValidator: (validator?: (value: Option_2<T>) => Option_2<string>) => void;
    /**
     * The formatter used to generate the {@link displayValue} from the current {@link value}.
     */
    readonly formatter: ValueFormatter<T>;
    /**
     * Sets the formatter used to generate the {@link displayValue}.
     *
     * @param formatter The new formatter to use, or `undefined` to revert to the default formatter.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    readonly setFormatter: (formatter: Option_2<ValueFormatter<T>>) => void;
    /**
     * The universe of possible values for this editable value.
     *
     * @example
     * `Enum` and `Boolean` attributes have a fixed set of possible values, which a component may want to offer as
     * options to the user.
     */
    readonly universe?: T[];
}

/** An `endsWith` condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type EndsWithCondition = BinaryFunctionExpression<"ends-with", AttributeExpression, LiteralExpression>;

declare type EqualityFunction = "=" | "!=";

/** An `equals` (`=`) condition which takes two {@link ValueExpression} arguments. */
declare type EqualsCondition = BinaryFunctionExpression<"=", ValueExpression>;

/**
 * Prop value representing a file
 */
export declare interface FileValue {
    /**
     * The file's unique resource identifier
     */
    readonly uri: string;
    /**
     * The file's name including extension
     */
    readonly name?: string;
}

/**
 * Base type for all expression objects which can be used as a filter condition on a data source.
 *
 * @property {"function"} type Identifies the expression as a filter function.
 * @property {string} name The name of the function, which can be used to narrow the type to a specific filter condition
 * type.
 *
 * @example
 * if (filter.type === "function") {
 *     switch (filter.name) {
 *         case "=": // Equals
 *             ...
 *             break;
 *         case "!=": // Not equal
 *             ...
 *             break;
 *         ...
 *     }
 * }
 */
declare type FilterCondition = AndCondition | OrCondition | NotCondition | EqualsCondition | NotEqualCondition | GreaterThanCondition | GreaterThanOrEqualCondition | LessThanCondition | LessThanOrEqualCondition | ContainsCondition | StartsWithCondition | EndsWithCondition | DayEqualsCondition | DayNotEqualCondition | DayGreaterThanCondition | DayGreaterThanOrEqualCondition | DayLessThanCondition | DayLessThanOrEqualCondition;

/**
 * Base type for all expression objects for data source filtering, which can be either a {@link FilterCondition} or a
 * {@link ValueExpression}.
 */
declare type FilterExpression = FilterCondition | ValueExpression;

declare type FilterFunction = BooleanFunction | ComparisonFunction | DayComparisonFunction | StringFunction;

/**
 * Built-in formatter type constants, identifying {@link NumberFormatter} and {@link DateTimeFormatter}.
 */
export declare enum FormatterType {
    Number = "number",
    DateTime = "datetime"
}

declare interface FunctionExpression<TName extends FilterFunction> {
    readonly type: "function";
    readonly name: TName;
}

declare interface GlyphIcon {
    readonly type: "glyph";
    readonly iconClass: string;
}

/** A `greaterThan` (`>`) condition which takes two {@link ValueExpression} arguments. */
declare type GreaterThanCondition = BinaryFunctionExpression<">", ValueExpression>;

/** A `greaterThanOrEqual` (`>=`) condition which takes two {@link ValueExpression} arguments. */
declare type GreaterThanOrEqualCondition = BinaryFunctionExpression<">=", ValueExpression>;

declare type GUID_2 = string & {
    __guidTag: any;
};
export { GUID_2 as GUID }

/**
 * Prop value representing all possible types of icons in the pluggable widget platform.
 */
export declare type IconValue = WebIcon | NativeIcon;

/**
 * Prop value representing images in the pluggable widget platform.
 */
export declare type ImageValue = WebImage | NativeImage;

declare interface InvalidParseResult {
    readonly valid: false;
}

/** A `lessThan` (`<`) condition which takes two {@link ValueExpression} arguments. */
declare type LessThanCondition = BinaryFunctionExpression<"<", ValueExpression>;

/** A `lessThanOrEqual` (`<=`) condition which takes two {@link ValueExpression} arguments. */
declare type LessThanOrEqualCondition = BinaryFunctionExpression<"<=", ValueExpression>;

/**
 * Property value representing action property linked to a data source.
 */
export declare interface ListActionValue {
    /**
     * Use {@link get} instead.
     * @deprecated
     */
    (item: ObjectItem): ActionValue;
    /**
     * Returns action value based on provided object item.
     *
     * @param item Instance of {@link ObjectItem} from the linked data source.
     */
    get: (item: ObjectItem) => ActionValue;
}

/**
 * The unique id of an association linked to a data source.
 */
declare type ListAssociationId = string & {
    __associationIdTag: never;
};

declare interface ListAssociationValue<T extends ObjectItem | ObjectItem[]> {
    /**
     * Returns dynamic value of the object item or object item array configured by the user based on the provided object item.
     *
     * @param item Instance of {@link ObjectItem} from the linked data source.
     */
    get: (item: ObjectItem) => DynamicValue<T>;
    /**
     * The unique id of the association.
     *
     * @remarks
     * The association id is used to refer to the association when configuring the filtering of a data source.
     */
    id: ListAssociationId;
    /**
     * Flag showing if this association can be used in a filter condition on the linked data source.
     */
    filterable: boolean;
}

/**
 * The unique id of an attribute linked to a data source.
 */
declare type ListAttributeId = string & {
    __attributeIdTag: never;
};

/**
 * Property value representing attribute property linked to a data source.
 */
export declare interface ListAttributeValue<T extends AttributeValue_2 = AttributeValue_2> {
    /**
     * Use {@link get} instead.
     * @deprecated
     */
    (item: ObjectItem): EditableValue<T>;
    /**
     * Returns editable value of the attribute configured by the user based on the provided object item.
     *
     * @param item Instance of {@link ObjectItem} from the linked data source.
     */
    get: (item: ObjectItem) => EditableValue<T>;
    /**
     * The unique id of the attribute.
     *
     * @remarks
     * The attribute id is used to refer to the attribute when configuring the sorting and filtering of a data source.
     */
    id: ListAttributeId;
    /**
     * Flag showing if this attribute can be used to define sort order on the linked data source.
     */
    sortable: boolean;
    /**
     * Flag showing if this attribute can be used in a filter condition on the linked data source.
     */
    filterable: boolean;
    /**
     * The {@link AttributeType} of this attribute.
     */
    type: AttributeType_2;
    /**
     * The default formatter used to format and parse values for this attribute.
     */
    formatter: ValueFormatter<T>;
    /**
     * The universe of possible values for this attribute.
     *
     * @remarks
     * `Enum` and `Boolean` attributes have a fixed set of possible values, which a component may want to offer as
     * filtering options to the user.
     */
    universe: Option_2<T[]>;
}

/**
 * Property value representing expression property linked to a data source.
 */
export declare interface ListExpressionValue<T extends AttributeValue_2 = AttributeValue_2> {
    /**
     * Use {@link get} instead.
     * @deprecated
     */
    (item: ObjectItem): DynamicValue<T>;
    /**
     * Returns dynamic value that represents result of the expression configured by the user based on the provided object item.
     *
     * @param item Instance of {@link ObjectItem} from the linked data source.
     */
    get: (item: ObjectItem) => DynamicValue<T>;
}

/**
 * Prop value representing a read only multi-reference association value linked to a data source.
 */
export declare type ListReferenceSetValue = ListAssociationValue<ObjectItem[]> & {
    type: "ReferenceSet";
};

/**
 * Prop value representing a read only single-reference association value linked to a data source.
 */
export declare type ListReferenceValue = ListAssociationValue<ObjectItem> & {
    type: "Reference";
};

/**
 * Prop value representing a list of objects, where each object is represented by an {@link ObjectItem}.
 * Like {@link DynamicValue}, this value has a {@link ValueStatus} which indicates whether the list is available.
 * It also provides control over the offset, limit and sort order used when retrieving data.
 */
export declare interface ListValue {
    /**
     * The current status of the list.
     */
    readonly status: ValueStatus;
    /**
     * A non-negative integer (zero-based) representing the offset that was last used to retrieve data. Default value is
     * {@code 0}.
     */
    readonly offset: number;
    /**
     * A non-negative integer representing the limit that was last used to retrieve data. Default value is
     * {@code Number.POSITIVE_INFINITY}.
     */
    readonly limit: number;
    /**
     * An array of {@link SortInstruction} representing the sort order that was last used to retrieve data.
     */
    readonly sortOrder: SortInstruction[];
    /**
     * A {@link FilterCondition} object representing the filter that was last used to retrieve data, or
     * {@code undefined} if there is no filter.
     */
    readonly filter: Option_2<FilterCondition>;
    /**
     * Sets the offset to the given value. If the offset is different from the current offset, this will trigger a
     * request for a new {@link ListValue}.
     *
     * @param offset A non-negative integer (zero-based) representing the new offset.
     *
     * @remark If the given offset is not a non-negative integer, an error will be thrown.
     * @remark This function returns nothing, but will cause the widget to receive new props.
     * @remark When user returns to a previously visited page, value of {@link offset} is automatically restored.
     */
    setOffset: (offset: number) => void;
    /**
     * Sets the limit to the given value. If the limit is different from the current limit, this will trigger a
     * request for a new {@link ListValue}. If the limit is zero, no request will be sent, but an empty {@see ListValue}
     * will be returned immediately. Passing {@code undefined} will reset the limit to its default value.
     *
     * @param limit A non-negative integer (zero-based) representing the new limit, or {@code undefined}.
     *
     * @remark If the given limit is neither a non-negative integer nor {@code undefined}, an error will be thrown.
     * @remark This function returns nothing, but will cause the widget to receive new props.
     * @remark When user returns to a previously visited page, value of {@link limit} is automatically restored.
     */
    setLimit: (limit: Option_2<number>) => void;
    /**
     * Sets whether a {@link totalCount} value should be retrieved.
     *
     * @param needTotalCount A flag indicating whether {@link totalCount} should be retrieved.
     *
     * @remark If the data source does not support retrieving a {@link totalCount}, calling {@link requestTotalCount}
     * has no effect.
     * @remark Computing {@link totalCount} might consume significant resources and not all data source types support
     * it, so we advise to use {@link hasMoreItems} instead whenever possible.
     */
    requestTotalCount: (needTotalCount: boolean) => void;
    /**
     * Sets the sort order to the given value. If the sort order is different from the current sort order,
     * this will trigger a request for a new {@link ListValue}. Passing {@code undefined} will reset the sort order
     * to its default value.
     *
     * @param sortOrder An array of {@link SortInstruction} representing the new sort order, or {@code undefined}.
     *
     * @remark When user returns to a previously visited page, value of {@link sortOrder} is automatically restored.
     */
    setSortOrder: (sortOrder: Option_2<SortInstruction[]>) => void;
    /**
     * Sets the filter to the given condition. If the filter is different from the current filter, this will trigger a
     * request for a new {@link ListValue}. Passing {@code undefined} will remove the filter.
     *
     * @param filter A {@link FilterCondition} object representing the new filter, or {@code undefined}.
     *
     * @remark When user returns to a previously visited page, value of {@link filter} is automatically restored.
     */
    setFilter: (filter: Option_2<FilterCondition>) => void;
    /**
     * Triggers a request for a new {@list ListValue}. Preserves the current state of {@link limit}, {@link offset}, {@link filter}, {@link sortOrder} and {@link requestTotalCount}.
     */
    reload: () => void;
    /**
     * The most recent list of objects, if available.
     *
     * @remark This property is always present when the status is available. When the status is loading, it is
     * optionally present and contains the value received previously.
     */
    readonly items?: ObjectItem[];
    /**
     * Indicates whether there are more objects beyond the limit of the most recent list, if available.
     *
     * @remark This property is always present when the status is available. When the status is loading, it is
     * optionally present and contains the value received previously.
     */
    readonly hasMoreItems?: boolean;
    /**
     * The total number of objects this {@link ListValue} can return, if available. To receive {@link totalCount} widget
     * must explicitly request it with {@link requestTotalCount}. Not all data sources provide `totalCount`.
     *
     * @remark This property can be present when the status is available. When the status is loading, it is optionally
     * present and contains the value received previously.
     * @remark Computing {@link totalCount} might consume significant resources and not all data source types support
     * it, so we advise to use {@link hasMoreItems} instead whenever possible.
     */
    readonly totalCount?: number;
}

/**
 * Property value representing widget property linked to a data source.
 */
export declare interface ListWidgetValue {
    /**
     * Use {@link get} instead.
     * @deprecated
     */
    (item: ObjectItem): ReactNode;
    /**
     * Returns widgets configured by user in form of a react node rendered based on provided object item.
     *
     * @param item Instance of {@link ObjectItem} from the linked data source.
     */
    get: (item: ObjectItem) => ReactNode;
}

/**
 * An expression which represents a literal value.
 *
 * @property {"literal"} type Identifies the expression as an literal expression.
 * @property {LiteralValue} value The literal value of this expression.
 * @property {LiteralType} valueType The type of this expression, which narrows the type of the `value` property.
 *
 * @example
 * if (filter.type === "literal" && filter.valueType == "DateTime") {
 *     const time = filter.value.getTime();
 *     ...
 * }
 */
declare type LiteralExpression = TypedLiteralExpression<"undefined", undefined> | TypedLiteralExpression<"string", string> | TypedLiteralExpression<"boolean", boolean> | TypedLiteralExpression<"DateTime", Date> | TypedLiteralExpression<"Numeric", BigJS_2> | TypedLiteralExpression<"Reference", GUID_2> | TypedLiteralExpression<"ReferenceSet", GUID_2[]>;

/** Possible types for a {@link LiteralExpression}. */
declare type LiteralType = "undefined" | "string" | "boolean" | "DateTime" | "Numeric" | AssociationType;

/** Allowed literal value in a {@link LiteralExpression}. */
declare type LiteralValue = PrimitiveLiteralValue | GUID_2 | GUID_2[];

/**
 * Prop value representing a modifiable value with validation and without formatting and parsing. Like
 * {@link DynamicValue}, this value has a {@link ValueStatus}. The value may be in a {@link readOnly} state which
 * prevents editing.
 *
 * @typeParam T The type of the contained value.
 */
export declare interface ModifiableValue<T> {
    /**
     * The current status of the value.
     */
    readonly status: ValueStatus;
    /**
     * Whether the value is read-only.
     *
     * @example
     * A read-only value can be the result of access restrictions or the current {@link status}.
     *
     * @remark
     * An attempt to call {@link setValue} while the value is read-only will cause a DEBUG-level
     * warning message.
     */
    readonly readOnly: boolean;
    /**
     * The value, if available, or the previous value when currently loading.
     */
    readonly value: Option_2<T>;
    /**
     * Sets the value
     *
     * @param value The new value.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     * @remark
     * An attempt to call this function while the value is read-only will cause a DEBUG-level warning message.
     */
    readonly setValue: (value: Option_2<T>) => void;
    /**
     * The validation message, if the value is currently invalid.
     *
     * @example
     * A validation message will be set if the value is invalid for its attribute or rejected by a validation expression.
     *
     * @remark
     * To set a custom validator, use {@link setValidator}.
     */
    readonly validation: Option_2<string>;
    /**
     * Sets a custom validator function.
     *
     * @param validator The new custom validator, or `undefined` to clear it.
     *
     * @remark
     * The custom validator does not replace the other types of validations which occur when the value is changed.
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    readonly setValidator: (validator?: (value: Option_2<T>) => Option_2<string>) => void;
}

declare interface MultiaryFunctionExpression<TName extends FilterFunction, TArg extends FilterExpression> extends FunctionExpression<TName> {
    readonly args: Readonly<TArg[]>;
}

/**
 * Prop value representing all possible types of icons for the native platform.
 *
 * @property type The type of icon: `"glyph"` or `"image"`.
 * @property iconUrl The image source for the icon (only for {@link type} `"image"`).
 * @property iconClass The class for the glyph icon (only for {@link type} `"glyph"`).
 */
export declare type NativeIcon = GlyphIcon | NativeImageIcon | undefined;

/**
 * Prop value representing images for the native platform.
 *
 * @see ImageURISource
 */
export declare type NativeImage = Readonly<(ImageURISource & {
    name?: string;
}) | string | number>;

declare interface NativeImageIcon {
    readonly type: "image";
    readonly iconUrl: Readonly<ImageURISource | string>;
}

/** A logical `not` (invert) condition which takes a single {@link FilterCondition} argument. */
declare type NotCondition = UnaryFunctionExpression<"not", FilterCondition>;

/** A `notEqual` (`!=`) condition which takes two {@link ValueExpression} arguments. */
declare type NotEqualCondition = BinaryFunctionExpression<"!=", ValueExpression>;

/**
 * Built-in formatter/parser for editable number values (represented by the {@link BigJS} type). This formatter type
 * supports configuration options for number formatting and parsing.
 */
export declare interface NumberFormatter extends TypedFormatter<BigJS_2> {
    /**
     * Identifies this formatter as a {@link NumberFormatter} within the {@link ValueFormatter} union type.
     */
    readonly type: FormatterType.Number;
    /**
     * The configuration of this formatter.
     */
    readonly config: NumberFormatterConfig;
    /**
     * Creates a formatter/parser for numbers with the given configuration options.
     *
     * @param config The new configuration options to use.
     *
     * @return A new {@link NumberFormatter}.
     *
     * @remark
     * Note that this function does not alter the existing formatter in any way, it only returns a new one with a
     * different configuration.
     */
    withConfig: (config: NumberFormatterConfig) => NumberFormatter;
}

export declare interface NumberFormatterConfig {
    readonly groupDigits: boolean;
    readonly decimalPrecision?: number;
}

/**
 * An object item returned by a data source. This object does not provide direct access to any data attributes, but it
 * can be passed to various API functions (like a widgets template).
 *
 * @property id The {@link GUID} of the object.
 */
export declare interface ObjectItem {
    id: GUID_2;
}

declare type Option_2<T> = T | undefined;
export { Option_2 as Option }

/** A logical `or` condition which takes two or more {@link FilterCondition} arguments. */
declare type OrCondition = MultiaryFunctionExpression<"or", FilterCondition>;

/**
 * @property valid Whether the value was parsed successfully.
 * @property value The parsed value, if successful.
 *
 * @typeParam TVal The type of the parsed value.
 */
export declare type ParseResult<TVal> = ValidParseResult<TVal> | InvalidParseResult;

/**
 * Type representing all possible prop values in the pluggable widget platform.
 */
export declare type PluginWidgetProp = PrimitiveValue | PrimitiveValue[] | ReactNode | ActionValue | DynamicValue<AttributeValue_2 | FileValue | ImageValue | IconValue> | EditableValue | ListValue | ListActionValue | ListAttributeValue | ListExpressionValue | ListWidgetValue | ListReferenceValue | ListReferenceSetValue | ReferenceValue | ReferenceSetValue | PluginWidgetProps | PluginWidgetProps[];

/**
 * Collection of all props for a pluggable widget.
 */
export declare interface PluginWidgetProps {
    [name: string]: PluginWidgetProp;
}

declare type PrimitiveLiteralValue = undefined | string | boolean | Date | BigJS_2;

/**
 * Primitive prop values in the pluggable widget platform.
 */
export declare type PrimitiveValue = number | string | boolean | null;

/**
 * Prop value representing a modifiable multi-reference association value with validation and without formatting and parsing.
 * Like {@link DynamicValue}, this value has a {@link ValueStatus}. The value may be in a {@link readOnly} state which
 * prevents editing.
 */
export declare type ReferenceSetValue = ModifiableValue<ObjectItem[]> & {
    type: "ReferenceSet";
};

/**
 * Prop value representing a modifiable single-reference association value with validation and without formatting and parsing.
 * Like {@link DynamicValue}, this value has a {@link ValueStatus}. The value may be in a {@link readOnly} state which
 * prevents editing.
 */
export declare type ReferenceValue = ModifiableValue<ObjectItem> & {
    type: "Reference";
};

/**
 * Simple formatter/parser for editable values, without any configuration options.
 *
 * @typeParam T The type of the parsed value.
 */
export declare interface SimpleFormatter<T> {
    /**
     * Formats the given value as text.
     *
     * @param value The value to format.
     */
    format: (value?: T) => string;
    /**
     * Parses the given display value.
     *
     * @param value The value to parse.
     *
     * @return A {@link ParseResult} indicating whether the parser could produce a valid result.
     */
    parse: (value: string) => ParseResult<T>;
}

declare type SortDirection = "asc" | "desc";

declare type SortInstruction = [id: ListAttributeId, dir: SortDirection];

/** An `startsWith` condition which takes a {@link AttributeExpression} and a {@link LiteralExpression} as arguments. */
declare type StartsWithCondition = BinaryFunctionExpression<"starts-with", AttributeExpression, LiteralExpression>;

declare type StringFunction = "contains" | "starts-with" | "ends-with";

export declare interface Style {
    [key: string]: CustomStyle | ViewStyle | TextStyle | ImageStyle;
}

declare interface TypedFormatter<T> extends SimpleFormatter<T> {
    readonly type: FormatterType;
}

declare interface TypedLiteralExpression<TType extends LiteralType, TVal extends LiteralValue> {
    readonly type: "literal";
    readonly value: TVal;
    readonly valueType: TType;
}

declare interface UnaryFunctionExpression<TName extends FilterFunction, TArg extends FilterExpression> extends FunctionExpression<TName> {
    readonly arg: TArg;
}

declare interface ValidParseResult<TVal> {
    readonly valid: true;
    readonly value?: TVal;
}

/**
 * A value expression can be used as an argument for various comparison filter functions.
 *
 * @property {"attribute" | "literal" | "association"} type Identifies the expression as an {@link AttributeExpression}, {@link LiteralExpression} or
 * {@link AssociationExpression}.
 */
declare type ValueExpression = AttributeExpression | LiteralExpression | AssociationExpression;

/**
 * Formatter/parser for editable values, either a built-in formatter with configuration options ({@link NumberFormatter}
 * or {@link DateTimeFormatter}) or a {@link SimpleFormatter}.
 *
 * @property type A {@link FormatterType} constant identifying the built-in formatter type, if set.
 *
 * @typeParam T The type of the parsed value.
 *
 * @remark
 * The `type` property can be used as a type guard to narrow this union type to a specific built-in formatter type.
 */
declare type ValueFormatter<T> = (TypedFormatter<T> & (NumberFormatter | DateTimeFormatter)) | (SimpleFormatter<T> & {
    readonly type?: never;
});

/**
 * Expresses the status of a {@link DynamicValue}.
 */
export declare const enum ValueStatus {
    /**
     * The value is available, up to date, and can be used.
     */
    Available = "available",
    /**
     * The value is unavailable and won't be, at least until some significant change like user interaction happens.
     *
     * @example
     * When {@link DynamicValue} represents a value of a {@link https://docs.mendix.com/refguide/text#text-template | Text template}
     * with parameters dependent on the context, but the parent Data view has no object, then that value cannot be
     * computed and is marked as unavailable.
     */
    Unavailable = "unavailable",
    /**
     * The value is temporary unavailable or outdated.
     *
     * @example
     * When {@link DynamicValue} represents a value of a {@link https://docs.mendix.com/refguide/text#text-template | Text template}
     * with parameters dependent on the context, but the parent Data view is still waiting for its object to arrive or
     * is refreshing its Data source due to {@link https://docs.mendix.com/refguide/change-object#3-2-refresh-in-client | refresh in client},
     * then the value is marked as loading.
     */
    Loading = "loading"
}

/**
 * Prop value representing all possible types of icons for the web platform.
 *
 * @property type The type of icon: `"glyph"` or `"image"`.
 * @property iconUrl The image source for the icon (only for {@link type} `"image"`).
 * @property iconClass The CSS class for the glyph icon (only for {@link type} `"glyph"`).
 */
export declare type WebIcon = GlyphIcon | WebImageIcon | undefined;

/**
 * Prop value representing images for the web platform.
 *
 * @property uri The source URI for the image.
 * @property altText The alternative text for the image.
 * @property name The image file name.
 */
export declare interface WebImage {
    readonly uri: string;
    readonly name?: string;
    readonly altText?: string;
}

declare interface WebImageIcon {
    readonly type: "image";
    readonly iconUrl: string;
}

export { }
